{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('prop-types')) : typeof define === 'function' && define.amd ? define(['exports', 'react', 'prop-types'], factory) : (global = global || self, factory(global.ReactMinimalPieChart = {}, global.React, global.PropTypes));\n})(this, function (exports, React, PropTypes) {\n  'use strict';\n\n  var React__default = 'default' in React ? React['default'] : React;\n  PropTypes = PropTypes && PropTypes.hasOwnProperty('default') ? PropTypes['default'] : PropTypes;\n\n  function _extends() {\n    _extends = Object.assign || function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n\n      return target;\n    };\n\n    return _extends.apply(this, arguments);\n  }\n\n  function _inheritsLoose(subClass, superClass) {\n    subClass.prototype = Object.create(superClass.prototype);\n    subClass.prototype.constructor = subClass;\n    subClass.__proto__ = superClass;\n  }\n\n  function _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n\n    for (i = 0; i < sourceKeys.length; i++) {\n      key = sourceKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      target[key] = source[key];\n    }\n\n    return target;\n  }\n\n  var partialCircle = function partialCircle(cx, cy, r, start, end) {\n    var length = end - start;\n    if (length === 0) return [];\n    var fromX = r * Math.cos(start) + cx;\n    var fromY = r * Math.sin(start) + cy;\n    var toX = r * Math.cos(end) + cx;\n    var toY = r * Math.sin(end) + cy;\n    var large = Math.abs(length) <= Math.PI ? '0' : '1';\n    var sweep = length < 0 ? '0' : '1';\n    return [['M', fromX, fromY], ['A', r, r, 0, large, sweep, toX, toY]];\n  };\n\n  var svgPartialCircle = partialCircle;\n  var PI = Math.PI;\n\n  function degreesToRadians(degrees) {\n    return degrees * PI / 180;\n  }\n\n  function evaluateLabelTextAnchor(_temp) {\n    var _ref = _temp === void 0 ? {} : _temp,\n        labelPosition = _ref.labelPosition,\n        lineWidth = _ref.lineWidth,\n        labelHorizontalShift = _ref.labelHorizontalShift; // Label in the vertical center\n\n\n    if (labelHorizontalShift === 0) {\n      return 'middle';\n    } // Outward label\n\n\n    if (labelPosition > 100) {\n      return labelHorizontalShift > 0 ? 'start' : 'end';\n    } // Inward label\n\n\n    var innerRadius = 100 - lineWidth;\n\n    if (labelPosition < innerRadius) {\n      return labelHorizontalShift > 0 ? 'end' : 'start';\n    } // Overlying label\n\n\n    return 'middle';\n  }\n\n  function valueBetween(value, min, max) {\n    if (value > max) return max;\n    if (value < min) return min;\n    return value;\n  }\n\n  function extractPercentage(value, percentage) {\n    return value * percentage / 100;\n  }\n\n  function makePathCommands(cx, cy, startAngle, lengthAngle, radius) {\n    var patchedLengthAngle = valueBetween(lengthAngle, -359.999, 359.999);\n    return svgPartialCircle(cx, cy, // center X and Y\n    radius, degreesToRadians(startAngle), degreesToRadians(startAngle + patchedLengthAngle)).map(function (command) {\n      return command.join(' ');\n    }).join(' ');\n  }\n\n  function ReactMinimalPieChartPath(_ref) {\n    var cx = _ref.cx,\n        cy = _ref.cy,\n        startAngle = _ref.startAngle,\n        lengthAngle = _ref.lengthAngle,\n        radius = _ref.radius,\n        lineWidth = _ref.lineWidth,\n        reveal = _ref.reveal,\n        title = _ref.title,\n        props = _objectWithoutPropertiesLoose(_ref, [\"cx\", \"cy\", \"startAngle\", \"lengthAngle\", \"radius\", \"lineWidth\", \"reveal\", \"title\"]);\n\n    var actualRadio = radius - lineWidth / 2;\n    var pathCommands = makePathCommands(cx, cy, startAngle, lengthAngle, actualRadio);\n    var strokeDasharray;\n    var strokeDashoffset; // Animate/hide paths with \"stroke-dasharray\" + \"stroke-dashoffset\"\n    // https://css-tricks.com/svg-line-animation-works/\n\n    if (typeof reveal === 'number') {\n      var pathLength = degreesToRadians(actualRadio) * lengthAngle;\n      strokeDasharray = Math.abs(pathLength);\n      strokeDashoffset = strokeDasharray - extractPercentage(strokeDasharray, reveal);\n    }\n\n    return React__default.createElement(\"path\", _extends({\n      d: pathCommands,\n      strokeWidth: lineWidth,\n      strokeDasharray: strokeDasharray,\n      strokeDashoffset: strokeDashoffset\n    }, props), title && React__default.createElement(\"title\", null, title));\n  }\n\n  ReactMinimalPieChartPath.displayName = 'ReactMinimalPieChartPath';\n  ReactMinimalPieChartPath.propTypes = {\n    cx: PropTypes.number.isRequired,\n    cy: PropTypes.number.isRequired,\n    startAngle: PropTypes.number,\n    lengthAngle: PropTypes.number,\n    radius: PropTypes.number,\n    lineWidth: PropTypes.number,\n    reveal: PropTypes.number,\n    title: PropTypes.oneOfType([PropTypes.number, PropTypes.string])\n  };\n  ReactMinimalPieChartPath.defaultProps = {\n    startAngle: 0,\n    lengthAngle: 0,\n    lineWidth: 100,\n    radius: 100\n  };\n  var stylePropType = PropTypes.objectOf(PropTypes.oneOfType([PropTypes.number, PropTypes.string]));\n  var dataPropType = PropTypes.arrayOf(PropTypes.shape({\n    title: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n    value: PropTypes.number.isRequired,\n    color: PropTypes.string,\n    key: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n    style: stylePropType\n  }));\n\n  function ReactMinimalPieChartLabel(_ref) {\n    var data = _ref.data,\n        dataIndex = _ref.dataIndex,\n        color = _ref.color,\n        props = _objectWithoutPropertiesLoose(_ref, [\"data\", \"dataIndex\", \"color\"]);\n\n    return React__default.createElement(\"text\", _extends({\n      textAnchor: \"middle\",\n      dominantBaseline: \"middle\",\n      fill: color\n    }, props));\n  }\n\n  ReactMinimalPieChartLabel.displayName = 'ReactMinimalPieChartLabel';\n  ReactMinimalPieChartLabel.propTypes = {\n    data: dataPropType,\n    dataIndex: PropTypes.number,\n    color: PropTypes.string\n  };\n\n  function extractAbsoluteCoordinates(props) {\n    var _props$viewBoxSize = props.viewBoxSize,\n        viewBoxWidth = _props$viewBoxSize[0],\n        viewBoxHeight = _props$viewBoxSize[1];\n    return {\n      cx: extractPercentage(props.cx, viewBoxWidth),\n      cy: extractPercentage(props.cy, viewBoxHeight),\n      radius: extractPercentage(props.radius, viewBoxWidth)\n    };\n  }\n\n  function sumValues(data) {\n    return data.reduce(function (acc, dataEntry) {\n      return acc + dataEntry.value;\n    }, 0);\n  } // Append \"percentage\", \"degrees\" and \"startOffset\" into each data entry\n\n\n  function extendData(_ref) {\n    var data = _ref.data,\n        totalAngle = _ref.lengthAngle,\n        totalValue = _ref.totalValue,\n        paddingAngle = _ref.paddingAngle;\n    var total = totalValue || sumValues(data);\n    var normalizedTotalAngle = valueBetween(totalAngle, -360, 360);\n    var numberOfPaddings = Math.abs(normalizedTotalAngle) === 360 ? data.length : data.length - 1;\n    var singlePaddingDegrees = Math.abs(paddingAngle) * Math.sign(totalAngle);\n    var degreesTakenByPadding = singlePaddingDegrees * numberOfPaddings;\n    var degreesTakenByPaths = normalizedTotalAngle - degreesTakenByPadding;\n    var lastSegmentEnd = 0; // @NOTE: Shall we evaluate percentage accordingly to dataEntry.value's sign?\n\n    return data.map(function (dataEntry) {\n      var valueInPercentage = total === 0 ? 0 : dataEntry.value / total * 100;\n      var degrees = extractPercentage(degreesTakenByPaths, valueInPercentage);\n      var startOffset = lastSegmentEnd;\n      lastSegmentEnd = lastSegmentEnd + degrees + singlePaddingDegrees;\n      return _extends({\n        percentage: valueInPercentage,\n        degrees: degrees,\n        startOffset: startOffset\n      }, dataEntry);\n    });\n  }\n\n  function makeSegmentTransitionStyle(duration, easing, furtherStyles) {\n    if (furtherStyles === void 0) {\n      furtherStyles = {};\n    } // Merge CSS transition necessary for chart animation with the ones provided by \"segmentsStyle\"\n\n\n    var transition = [\"stroke-dashoffset \" + duration + \"ms \" + easing, furtherStyles.transition].filter(Boolean).join(',');\n    return {\n      transition: transition\n    };\n  }\n\n  function renderLabelItem(option, props, value) {\n    if (React__default.isValidElement(option)) {\n      return React__default.cloneElement(option, props);\n    }\n\n    var label = value;\n\n    if (typeof option === 'function') {\n      label = option(props);\n\n      if (React__default.isValidElement(label)) {\n        return label;\n      }\n    }\n\n    return React__default.createElement(ReactMinimalPieChartLabel, props, label);\n  }\n\n  function renderLabels(data, props) {\n    var _extractAbsoluteCoord = extractAbsoluteCoordinates(props),\n        cx = _extractAbsoluteCoord.cx,\n        cy = _extractAbsoluteCoord.cy,\n        radius = _extractAbsoluteCoord.radius;\n\n    var labelPosition = extractPercentage(radius, props.labelPosition);\n    return data.map(function (dataEntry, index) {\n      var startAngle = props.startAngle + dataEntry.startOffset;\n      var halfAngle = startAngle + dataEntry.degrees / 2;\n      var halfAngleRadians = degreesToRadians(halfAngle);\n      var dx = Math.cos(halfAngleRadians) * labelPosition;\n      var dy = Math.sin(halfAngleRadians) * labelPosition; // This object is passed as props to the \"label\" component\n\n      var labelProps = {\n        key: \"label-\" + (dataEntry.key || index),\n        x: cx,\n        y: cy,\n        dx: dx,\n        dy: dy,\n        textAnchor: evaluateLabelTextAnchor({\n          lineWidth: props.lineWidth,\n          labelPosition: props.labelPosition,\n          labelHorizontalShift: dx\n        }),\n        data: data,\n        dataIndex: index,\n        color: dataEntry.color,\n        style: props.labelStyle\n      };\n      return renderLabelItem(props.label, labelProps, dataEntry.value);\n    });\n  }\n\n  function renderSegments(data, props, hide) {\n    var style = props.segmentsStyle;\n\n    if (props.animate) {\n      var transitionStyle = makeSegmentTransitionStyle(props.animationDuration, props.animationEasing, style);\n      style = Object.assign({}, style, transitionStyle);\n    } // Hide/reveal the segment?\n\n\n    var reveal;\n\n    if (hide === true) {\n      reveal = 0;\n    } else if (typeof props.reveal === 'number') {\n      reveal = props.reveal;\n    } else if (hide === false) {\n      reveal = 100;\n    }\n\n    var _extractAbsoluteCoord2 = extractAbsoluteCoordinates(props),\n        cx = _extractAbsoluteCoord2.cx,\n        cy = _extractAbsoluteCoord2.cy,\n        radius = _extractAbsoluteCoord2.radius;\n\n    var lineWidth = extractPercentage(radius, props.lineWidth);\n    var paths = data.map(function (dataEntry, index) {\n      var startAngle = props.startAngle + dataEntry.startOffset;\n      return React__default.createElement(ReactMinimalPieChartPath, {\n        key: dataEntry.key || index,\n        cx: cx,\n        cy: cy,\n        startAngle: startAngle,\n        lengthAngle: dataEntry.degrees,\n        radius: radius,\n        lineWidth: lineWidth,\n        reveal: reveal,\n        title: dataEntry.title,\n        style: Object.assign({}, style, dataEntry.style),\n        stroke: dataEntry.color,\n        strokeLinecap: props.rounded ? 'round' : undefined,\n        fill: \"none\",\n        onMouseOver: props.onMouseOver && function (e) {\n          return props.onMouseOver(e, props.data, index);\n        },\n        onMouseOut: props.onMouseOut && function (e) {\n          return props.onMouseOut(e, props.data, index);\n        },\n        onClick: props.onClick && function (e) {\n          return props.onClick(e, props.data, index);\n        }\n      });\n    });\n\n    if (props.background) {\n      paths.unshift(React__default.createElement(ReactMinimalPieChartPath, {\n        key: \"bg\",\n        cx: cx,\n        cy: cy,\n        startAngle: props.startAngle,\n        lengthAngle: props.lengthAngle,\n        radius: radius,\n        lineWidth: lineWidth,\n        stroke: props.background,\n        strokeLinecap: props.rounded ? 'round' : undefined,\n        fill: \"none\"\n      }));\n    }\n\n    return paths;\n  }\n\n  var ReactMinimalPieChart =\n  /*#__PURE__*/\n  function (_Component) {\n    _inheritsLoose(ReactMinimalPieChart, _Component);\n\n    function ReactMinimalPieChart(props) {\n      var _this;\n\n      _this = _Component.call(this, props) || this;\n\n      if (_this.props.animate === true) {\n        _this.hideSegments = true;\n      }\n\n      return _this;\n    }\n\n    var _proto = ReactMinimalPieChart.prototype;\n\n    _proto.componentDidMount = function componentDidMount() {\n      var _this2 = this;\n\n      if (this.props.animate === true && requestAnimationFrame) {\n        this.initialAnimationTimerId = setTimeout(function () {\n          _this2.initialAnimationTimerId = null;\n          _this2.initialAnimationRAFId = requestAnimationFrame(function () {\n            _this2.initialAnimationRAFId = null;\n\n            _this2.startAnimation();\n          });\n        });\n      }\n    };\n\n    _proto.componentWillUnmount = function componentWillUnmount() {\n      if (this.initialAnimationTimerId) {\n        clearTimeout(this.initialAnimationTimerId);\n      }\n\n      if (this.initialAnimationRAFId) {\n        cancelAnimationFrame(this.initialAnimationRAFId);\n      }\n    };\n\n    _proto.startAnimation = function startAnimation() {\n      this.hideSegments = false;\n      this.forceUpdate();\n    };\n\n    _proto.render = function render() {\n      var props = this.props;\n\n      if (props.data === undefined) {\n        return null;\n      }\n\n      var extendedData = extendData(props);\n      return React__default.createElement(\"div\", {\n        className: props.className,\n        style: props.style\n      }, React__default.createElement(\"svg\", {\n        viewBox: \"0 0 \" + props.viewBoxSize[0] + \" \" + props.viewBoxSize[1],\n        width: \"100%\",\n        height: \"100%\",\n        style: {\n          display: 'block'\n        }\n      }, renderSegments(extendedData, props, this.hideSegments), props.label && renderLabels(extendedData, props), props.injectSvg && props.injectSvg()), props.children);\n    };\n\n    return ReactMinimalPieChart;\n  }(React.Component);\n\n  ReactMinimalPieChart.displayName = 'ReactMinimalPieChart';\n  ReactMinimalPieChart.propTypes = {\n    data: dataPropType,\n    cx: PropTypes.number,\n    cy: PropTypes.number,\n    viewBoxSize: PropTypes.arrayOf(PropTypes.number),\n    totalValue: PropTypes.number,\n    className: PropTypes.string,\n    style: stylePropType,\n    segmentsStyle: stylePropType,\n    background: PropTypes.string,\n    startAngle: PropTypes.number,\n    lengthAngle: PropTypes.number,\n    paddingAngle: PropTypes.number,\n    lineWidth: PropTypes.number,\n    radius: PropTypes.number,\n    rounded: PropTypes.bool,\n    animate: PropTypes.bool,\n    animationDuration: PropTypes.number,\n    animationEasing: PropTypes.string,\n    reveal: PropTypes.number,\n    children: PropTypes.node,\n    injectSvg: PropTypes.func,\n    label: PropTypes.oneOfType([PropTypes.func, PropTypes.element, PropTypes.bool]),\n    labelPosition: PropTypes.number,\n    labelStyle: stylePropType,\n    onMouseOver: PropTypes.func,\n    onMouseOut: PropTypes.func,\n    onClick: PropTypes.func\n  };\n  ReactMinimalPieChart.defaultProps = {\n    cx: 50,\n    cy: 50,\n    viewBoxSize: [100, 100],\n    startAngle: 0,\n    lengthAngle: 360,\n    paddingAngle: 0,\n    lineWidth: 100,\n    radius: 50,\n    rounded: false,\n    animate: false,\n    animationDuration: 500,\n    animationEasing: 'ease-out',\n    label: false,\n    labelPosition: 50,\n    onMouseOver: undefined,\n    onMouseOut: undefined,\n    onClick: undefined\n  };\n  exports.default = ReactMinimalPieChart;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"sources":["../node_modules/svg-partial-circle/index.js","../src/utils.js","../src/Path.js","../src/propTypes.js","../src/Label.js","../src/Chart.js"],"names":["partialCircle","length","end","fromX","r","Math","fromY","toX","toY","large","sweep","module","PI","degrees","labelPosition","lineWidth","labelHorizontalShift","innerRadius","value","patchedLengthAngle","valueBetween","degreesToRadians","startAngle","command","cx","cy","lengthAngle","radius","reveal","title","props","actualRadio","pathCommands","makePathCommands","pathLength","strokeDasharray","strokeDashoffset","extractPercentage","React","ReactMinimalPieChartPath","PropTypes","stylePropType","dataPropType","color","key","style","data","dataIndex","ReactMinimalPieChartLabel","string","viewBoxWidth","viewBoxHeight","acc","dataEntry","totalAngle","totalValue","paddingAngle","total","sumValues","normalizedTotalAngle","numberOfPaddings","singlePaddingDegrees","degreesTakenByPadding","degreesTakenByPaths","lastSegmentEnd","valueInPercentage","startOffset","percentage","furtherStyles","transition","label","option","extractAbsoluteCoordinates","halfAngle","halfAngleRadians","dx","dy","labelProps","x","y","textAnchor","evaluateLabelTextAnchor","labelStyle","renderLabelItem","transitionStyle","makeSegmentTransitionStyle","Object","hide","paths","ReactMinimalPieChart","Component","componentDidMount","setTimeout","requestAnimationFrame","componentWillUnmount","clearTimeout","cancelAnimationFrame","startAnimation","render","extendedData","extendData","display","renderSegments","renderLabels","viewBoxSize","className","segmentsStyle","background","rounded","animate","animationDuration","animationEasing","children","injectSvg","onMouseOver","onMouseOut","onClick","func","undefined"],"mappings":"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","sourcesContent":["'use strict'\n\n// from http://stackoverflow.com/a/18473154\nconst partialCircle = (cx, cy, r, start, end) => {\n\tconst length = end - start\n\tif (length === 0) return []\n\n\tconst fromX = r * Math.cos(start) + cx\n\tconst fromY = r * Math.sin(start) + cy\n\tconst toX = r * Math.cos(end) + cx\n\tconst toY = r * Math.sin(end) + cy\n\tconst large = Math.abs(length) <= Math.PI ? '0' : '1'\n\tconst sweep = length < 0 ? '0' : '1'\n\n\treturn [\n\t\t['M', fromX, fromY],\n\t\t['A', r, r, 0, large, sweep, toX, toY]\n\t]\n}\n\nmodule.exports = partialCircle\n","const PI = Math.PI;\n\nexport function degreesToRadians(degrees) {\n  return (degrees * PI) / 180;\n}\n\nexport function evaluateLabelTextAnchor({\n  labelPosition,\n  lineWidth,\n  labelHorizontalShift,\n} = {}) {\n  // Label in the vertical center\n  if (labelHorizontalShift === 0) {\n    return 'middle';\n  }\n  // Outward label\n  if (labelPosition > 100) {\n    return labelHorizontalShift > 0 ? 'start' : 'end';\n  }\n  // Inward label\n  const innerRadius = 100 - lineWidth;\n  if (labelPosition < innerRadius) {\n    return labelHorizontalShift > 0 ? 'end' : 'start';\n  }\n  // Overlying label\n  return 'middle';\n}\n\nexport function valueBetween(value, min, max) {\n  if (value > max) return max;\n  if (value < min) return min;\n  return value;\n}\n\nexport function extractPercentage(value, percentage) {\n  return (value * percentage) / 100;\n}\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport partialCircle from 'svg-partial-circle';\nimport { degreesToRadians, extractPercentage, valueBetween } from './utils';\n\nfunction makePathCommands(cx, cy, startAngle, lengthAngle, radius) {\n  const patchedLengthAngle = valueBetween(lengthAngle, -359.999, 359.999);\n\n  return partialCircle(\n    cx,\n    cy, // center X and Y\n    radius,\n    degreesToRadians(startAngle),\n    degreesToRadians(startAngle + patchedLengthAngle)\n  )\n    .map(command => command.join(' '))\n    .join(' ');\n}\n\nexport default function ReactMinimalPieChartPath({\n  cx,\n  cy,\n  startAngle,\n  lengthAngle,\n  radius,\n  lineWidth,\n  reveal,\n  title,\n  ...props\n}) {\n  const actualRadio = radius - lineWidth / 2;\n  const pathCommands = makePathCommands(\n    cx,\n    cy,\n    startAngle,\n    lengthAngle,\n    actualRadio\n  );\n  let strokeDasharray;\n  let strokeDashoffset;\n\n  // Animate/hide paths with \"stroke-dasharray\" + \"stroke-dashoffset\"\n  // https://css-tricks.com/svg-line-animation-works/\n  if (typeof reveal === 'number') {\n    const pathLength = degreesToRadians(actualRadio) * lengthAngle;\n    strokeDasharray = Math.abs(pathLength);\n    strokeDashoffset =\n      strokeDasharray - extractPercentage(strokeDasharray, reveal);\n  }\n\n  return (\n    <path\n      d={pathCommands}\n      strokeWidth={lineWidth}\n      strokeDasharray={strokeDasharray}\n      strokeDashoffset={strokeDashoffset}\n      {...props}\n    >\n      {title && <title>{title}</title>}\n    </path>\n  );\n}\n\nReactMinimalPieChartPath.displayName = 'ReactMinimalPieChartPath';\n\nReactMinimalPieChartPath.propTypes = {\n  cx: PropTypes.number.isRequired,\n  cy: PropTypes.number.isRequired,\n  startAngle: PropTypes.number,\n  lengthAngle: PropTypes.number,\n  radius: PropTypes.number,\n  lineWidth: PropTypes.number,\n  reveal: PropTypes.number,\n  title: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n};\n\nReactMinimalPieChartPath.defaultProps = {\n  startAngle: 0,\n  lengthAngle: 0,\n  lineWidth: 100,\n  radius: 100,\n};\n","import PropTypes from 'prop-types';\n\nexport const stylePropType = PropTypes.objectOf(\n  PropTypes.oneOfType([PropTypes.number, PropTypes.string])\n);\n\nexport const dataPropType = PropTypes.arrayOf(\n  PropTypes.shape({\n    title: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n    value: PropTypes.number.isRequired,\n    color: PropTypes.string,\n    key: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n    style: stylePropType,\n  })\n);\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport { dataPropType } from './propTypes';\n\nexport default function ReactMinimalPieChartLabel({\n  data,\n  dataIndex,\n  color,\n  ...props\n}) {\n  return (\n    <text\n      textAnchor=\"middle\"\n      dominantBaseline=\"middle\"\n      fill={color}\n      {...props}\n    />\n  );\n}\n\nReactMinimalPieChartLabel.displayName = 'ReactMinimalPieChartLabel';\n\nReactMinimalPieChartLabel.propTypes = {\n  data: dataPropType,\n  dataIndex: PropTypes.number,\n  color: PropTypes.string,\n};\n","import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport Path from './Path';\nimport DefaultLabel from './Label';\nimport { dataPropType, stylePropType } from './propTypes';\nimport {\n  degreesToRadians,\n  evaluateLabelTextAnchor,\n  extractPercentage,\n  valueBetween,\n} from './utils';\n\nfunction extractAbsoluteCoordinates(props) {\n  const [viewBoxWidth, viewBoxHeight] = props.viewBoxSize;\n  return {\n    cx: extractPercentage(props.cx, viewBoxWidth),\n    cy: extractPercentage(props.cy, viewBoxHeight),\n    radius: extractPercentage(props.radius, viewBoxWidth),\n  };\n}\n\nfunction sumValues(data) {\n  return data.reduce((acc, dataEntry) => acc + dataEntry.value, 0);\n}\n\n// Append \"percentage\", \"degrees\" and \"startOffset\" into each data entry\nfunction extendData({\n  data,\n  lengthAngle: totalAngle,\n  totalValue,\n  paddingAngle,\n}) {\n  const total = totalValue || sumValues(data);\n  const normalizedTotalAngle = valueBetween(totalAngle, -360, 360);\n  const numberOfPaddings =\n    Math.abs(normalizedTotalAngle) === 360 ? data.length : data.length - 1;\n  const singlePaddingDegrees = Math.abs(paddingAngle) * Math.sign(totalAngle);\n  const degreesTakenByPadding = singlePaddingDegrees * numberOfPaddings;\n  const degreesTakenByPaths = normalizedTotalAngle - degreesTakenByPadding;\n  let lastSegmentEnd = 0;\n\n  // @NOTE: Shall we evaluate percentage accordingly to dataEntry.value's sign?\n  return data.map(dataEntry => {\n    const valueInPercentage = total === 0 ? 0 : (dataEntry.value / total) * 100;\n    const degrees = extractPercentage(degreesTakenByPaths, valueInPercentage);\n    const startOffset = lastSegmentEnd;\n    lastSegmentEnd = lastSegmentEnd + degrees + singlePaddingDegrees;\n\n    return {\n      percentage: valueInPercentage,\n      degrees,\n      startOffset,\n      ...dataEntry,\n    };\n  });\n}\n\nfunction makeSegmentTransitionStyle(duration, easing, furtherStyles = {}) {\n  // Merge CSS transition necessary for chart animation with the ones provided by \"segmentsStyle\"\n  const transition = [\n    `stroke-dashoffset ${duration}ms ${easing}`,\n    furtherStyles.transition,\n  ]\n    .filter(Boolean)\n    .join(',');\n\n  return {\n    transition,\n  };\n}\n\nfunction renderLabelItem(option, props, value) {\n  if (React.isValidElement(option)) {\n    return React.cloneElement(option, props);\n  }\n\n  let label = value;\n  if (typeof option === 'function') {\n    label = option(props);\n    if (React.isValidElement(label)) {\n      return label;\n    }\n  }\n\n  return <DefaultLabel {...props}>{label}</DefaultLabel>;\n}\n\nfunction renderLabels(data, props) {\n  const { cx, cy, radius } = extractAbsoluteCoordinates(props);\n  const labelPosition = extractPercentage(radius, props.labelPosition);\n\n  return data.map((dataEntry, index) => {\n    const startAngle = props.startAngle + dataEntry.startOffset;\n    const halfAngle = startAngle + dataEntry.degrees / 2;\n    const halfAngleRadians = degreesToRadians(halfAngle);\n    const dx = Math.cos(halfAngleRadians) * labelPosition;\n    const dy = Math.sin(halfAngleRadians) * labelPosition;\n\n    // This object is passed as props to the \"label\" component\n    const labelProps = {\n      key: `label-${dataEntry.key || index}`,\n      x: cx,\n      y: cy,\n      dx,\n      dy,\n      textAnchor: evaluateLabelTextAnchor({\n        lineWidth: props.lineWidth,\n        labelPosition: props.labelPosition,\n        labelHorizontalShift: dx,\n      }),\n      data: data,\n      dataIndex: index,\n      color: dataEntry.color,\n      style: props.labelStyle,\n    };\n\n    return renderLabelItem(props.label, labelProps, dataEntry.value);\n  });\n}\n\nfunction renderSegments(data, props, hide) {\n  let style = props.segmentsStyle;\n  if (props.animate) {\n    const transitionStyle = makeSegmentTransitionStyle(\n      props.animationDuration,\n      props.animationEasing,\n      style\n    );\n    style = Object.assign({}, style, transitionStyle);\n  }\n\n  // Hide/reveal the segment?\n  let reveal;\n  if (hide === true) {\n    reveal = 0;\n  } else if (typeof props.reveal === 'number') {\n    reveal = props.reveal;\n  } else if (hide === false) {\n    reveal = 100;\n  }\n\n  const { cx, cy, radius } = extractAbsoluteCoordinates(props);\n  const lineWidth = extractPercentage(radius, props.lineWidth);\n  const paths = data.map((dataEntry, index) => {\n    const startAngle = props.startAngle + dataEntry.startOffset;\n\n    return (\n      <Path\n        key={dataEntry.key || index}\n        cx={cx}\n        cy={cy}\n        startAngle={startAngle}\n        lengthAngle={dataEntry.degrees}\n        radius={radius}\n        lineWidth={lineWidth}\n        reveal={reveal}\n        title={dataEntry.title}\n        style={Object.assign({}, style, dataEntry.style)}\n        stroke={dataEntry.color}\n        strokeLinecap={props.rounded ? 'round' : undefined}\n        fill=\"none\"\n        onMouseOver={\n          props.onMouseOver && (e => props.onMouseOver(e, props.data, index))\n        }\n        onMouseOut={\n          props.onMouseOut && (e => props.onMouseOut(e, props.data, index))\n        }\n        onClick={props.onClick && (e => props.onClick(e, props.data, index))}\n      />\n    );\n  });\n\n  if (props.background) {\n    paths.unshift(\n      <Path\n        key=\"bg\"\n        cx={cx}\n        cy={cy}\n        startAngle={props.startAngle}\n        lengthAngle={props.lengthAngle}\n        radius={radius}\n        lineWidth={lineWidth}\n        stroke={props.background}\n        strokeLinecap={props.rounded ? 'round' : undefined}\n        fill=\"none\"\n      />\n    );\n  }\n\n  return paths;\n}\n\nexport default class ReactMinimalPieChart extends Component {\n  constructor(props) {\n    super(props);\n\n    if (this.props.animate === true) {\n      this.hideSegments = true;\n    }\n  }\n\n  componentDidMount() {\n    if (this.props.animate === true && requestAnimationFrame) {\n      this.initialAnimationTimerId = setTimeout(() => {\n        this.initialAnimationTimerId = null;\n        this.initialAnimationRAFId = requestAnimationFrame(() => {\n          this.initialAnimationRAFId = null;\n          this.startAnimation();\n        });\n      });\n    }\n  }\n\n  componentWillUnmount() {\n    if (this.initialAnimationTimerId) {\n      clearTimeout(this.initialAnimationTimerId);\n    }\n    if (this.initialAnimationRAFId) {\n      cancelAnimationFrame(this.initialAnimationRAFId);\n    }\n  }\n\n  startAnimation() {\n    this.hideSegments = false;\n    this.forceUpdate();\n  }\n\n  render() {\n    const props = this.props;\n    if (props.data === undefined) {\n      return null;\n    }\n    const extendedData = extendData(props);\n\n    return (\n      <div className={props.className} style={props.style}>\n        <svg\n          viewBox={`0 0 ${props.viewBoxSize[0]} ${props.viewBoxSize[1]}`}\n          width=\"100%\"\n          height=\"100%\"\n          style={{ display: 'block' }}\n        >\n          {renderSegments(extendedData, props, this.hideSegments)}\n          {props.label && renderLabels(extendedData, props)}\n          {props.injectSvg && props.injectSvg()}\n        </svg>\n        {props.children}\n      </div>\n    );\n  }\n}\n\nReactMinimalPieChart.displayName = 'ReactMinimalPieChart';\n\nReactMinimalPieChart.propTypes = {\n  data: dataPropType,\n  cx: PropTypes.number,\n  cy: PropTypes.number,\n  viewBoxSize: PropTypes.arrayOf(PropTypes.number),\n  totalValue: PropTypes.number,\n  className: PropTypes.string,\n  style: stylePropType,\n  segmentsStyle: stylePropType,\n  background: PropTypes.string,\n  startAngle: PropTypes.number,\n  lengthAngle: PropTypes.number,\n  paddingAngle: PropTypes.number,\n  lineWidth: PropTypes.number,\n  radius: PropTypes.number,\n  rounded: PropTypes.bool,\n  animate: PropTypes.bool,\n  animationDuration: PropTypes.number,\n  animationEasing: PropTypes.string,\n  reveal: PropTypes.number,\n  children: PropTypes.node,\n  injectSvg: PropTypes.func,\n  label: PropTypes.oneOfType([\n    PropTypes.func,\n    PropTypes.element,\n    PropTypes.bool,\n  ]),\n  labelPosition: PropTypes.number,\n  labelStyle: stylePropType,\n  onMouseOver: PropTypes.func,\n  onMouseOut: PropTypes.func,\n  onClick: PropTypes.func,\n};\n\nReactMinimalPieChart.defaultProps = {\n  cx: 50,\n  cy: 50,\n  viewBoxSize: [100, 100],\n  startAngle: 0,\n  lengthAngle: 360,\n  paddingAngle: 0,\n  lineWidth: 100,\n  radius: 50,\n  rounded: false,\n  animate: false,\n  animationDuration: 500,\n  animationEasing: 'ease-out',\n  label: false,\n  labelPosition: 50,\n  onMouseOver: undefined,\n  onMouseOut: undefined,\n  onClick: undefined,\n};\n"]},"metadata":{},"sourceType":"script"}